let Joi,RefreshToken,User,CustomErrorHandler,bcrypt,jwtService,REFRESH_TOKEN;_60b‍.x([["default",()=>_60b‍.o]]);_60b‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_60b‍.w("../../models",[["RefreshToken",["RefreshToken"],function(v){RefreshToken=v}],["User",["User"],function(v){User=v}]]);_60b‍.w("../../Services/CustomErrorHandler",[["default",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_60b‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_60b‍.w("../../Services/jwtService",[["default",["jwtService"],function(v){jwtService=v}]]);_60b‍.w("../../config",[["REFRESH_TOKEN",["REFRESH_TOKEN"],function(v){REFRESH_TOKEN=v}]]);







const RegisterController ={
    async register (req , res , next){





        const registerSchema = Joi.object({
            name :  Joi.string().min(3).max(30).required(),
            email :  Joi.string().email().required(),
            password :  Joi.string().required(),
            repeat_password :  Joi.ref('password')
        });

        const {error} = registerSchema.validate(req.body);

        if(error){
            return next(error)
        }
//check if user alredy in database
         try{ 
            const exist =  await User.exists({ email : req.body.email });

            if(exist){
                return next(CustomErrorHandler.alreadyExists('this email is alredy taken'))
                
            }
        }
         catch(err){
            return next(err)
    
       }


       //hash password
       const hashedPassword = await bcrypt.hash(req.body.password ,10);

       //prepare the model
       const user  = new User({
        name : req.body.name,
        email : req.body.email,
        password : hashedPassword
       })
       _60b‍.g.console.log(user);

       let access_Token;
       let refresh_Token;
       try{
        const result = await user.save();
        // console.log(result);

        //Token
        access_Token= jwtService.sign({_id:result._id ,role:result.role})
        refresh_Token = jwtService.sign({_id:result._id , role: result.role}, '1y' , REFRESH_TOKEN)

        await RefreshToken.create({
            token: refresh_Token
        })
       }


        catch (err){
        return next(err);
        }
  

    
         res.json( { access_Token : access_Token , refresh_Token })
        
    }
}




_60b‍.d(RegisterController);