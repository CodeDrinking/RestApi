let Joi,User,RefreshToken,CustomErrorHandler,bcrypt,jwtService,REFRESH_TOKEN;_782‍.x([["default",()=>_782‍.o]]);_782‍.w("joi",[["default",["Joi"],function(v){Joi=v}]]);_782‍.w("../../models",[["User",["User"],function(v){User=v}],["RefreshToken",["RefreshToken"],function(v){RefreshToken=v}]]);_782‍.w("../../Services/CustomErrorHandler",[["default",["CustomErrorHandler"],function(v){CustomErrorHandler=v}]]);_782‍.w("bcrypt",[["default",["bcrypt"],function(v){bcrypt=v}]]);_782‍.w("../../Services/jwtService",[["default",["jwtService"],function(v){jwtService=v}]]);_782‍.w("../../config",[["REFRESH_TOKEN",["REFRESH_TOKEN"],function(v){REFRESH_TOKEN=v}]]);











const loginController = {
    async login(req , res , next){

        const loginSchema = Joi.object({
            email :  Joi.string().email().required(),
            password :  Joi.string().required()
        });
        const {error} = loginSchema.validate(req.body);

        if(error){
            return next(error);
        }
        
        try{
            const user= await User.findOne({email:req.body.email});
            if(!user){
                return next (CustomErrorHandler.wrongCred())
            }
            _782‍.g.console.log(user , req.body.password);
            const match = await bcrypt.compare(req.body.password , user.password);

            if(!match){
                return next(CustomErrorHandler.wrongCred())
            }
            //token
           const access_Token= jwtService.sign({_id:user._id ,role:user.role})
           const refresh_Token = jwtService.sign({_id:user._id , role: user.role}, '1y' , REFRESH_TOKEN)

        await RefreshToken.create({
            token: refresh_Token
        })
           res.json({access_Token , refresh_Token})

        }
        catch(err){
            return next(err)
        }   
    }

    
}

_782‍.d(loginController);